// Code generated by github.com/DIMO-Network/pkg/ruptela/codegen DO NOT EDIT.
package ruptela

const bitsInByte = 8
{{- range $oid, $rupSig := .Records }}
{{ if and (eq $rupSig.Offset 0.0) (eq $rupSig.Multiplier 1.0) (eq $rupSig.Type "Signed int.") (eq $rupSig.Type "Unsigned int.") -}}
{{ continue }}
{{ end }}
// Convert{{ $oid }} converts the given raw value to a float64.
// {{- if $rupSig.Units -}}Unit: '{{ $rupSig.Units }}'{{- end -}}{{- if $rupSig.MinValue }} Min: '{{- $rupSig.MinValue -}}'{{- end -}} {{- if $rupSig.MaxValue }} Max: '{{- $rupSig.MaxValue -}}'{{- end -}}.
func Convert{{ $oid }}(rawValue string) (float64, error) {
    const byteSize = {{ $rupSig.Size }}
    const offset = float64({{ $rupSig.Offset }})
    const nan = 1 << (byteSize*bitsInByte) - 1
    const multiplier = float64({{ $rupSig.Multiplier }})
    {{ if eq $rupSig.Type "Signed int." -}}
    rawInt, err := strconv.ParseInt(rawValue, 16, 64)
    if err != nil {
        return 0, fmt.Errorf("could not parse int: %w", err)
    }
    {{ else -}}
    rawInt, err := strconv.ParseUint(rawValue, 16, 64)
    if err != nil {
        return 0, fmt.Errorf("could not parse uint: %w", err)
    }
    if rawInt == nan {
        return 0, errNotFound
    }
    {{ end -}}
    {{ if $rupSig.ErrorSet -}}
    {{ $sign := "uint64" }}
    {{ if eq $rupSig.Type "Signed int." -}} {{ $sign := "int64" }} {{ end -}}
    if slices.Contains([]{{ $sign }}{ {{ range $_, $val := $rupSig.ErrorSet }}{{$val}}, {{end}} }, rawInt) {
		return 0, errNotFound
	}
    {{ end -}}
    {{ if $rupSig.ErrorRange -}}
    if {{ $rupSig.ErrorRange.Min }} <= rawInt && rawInt <= {{ $rupSig.ErrorRange.Max }} {
        return 0, errNotFound
    }
    {{ end -}}

    {{ if $rupSig.MinBig -}}
    if rawInt < {{ bigText $rupSig.MinBig }} {
        return 0, errNotFound
    }
    {{ end -}}
    {{ if $rupSig.MaxBig -}}
    if rawInt > {{ bigText $rupSig.MaxBig }} {
        return 0, errNotFound
    }
    {{ end -}}
    return float64(rawInt)*multiplier + offset, nil
}
{{ end }}
