// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package ruptela

import (
	"errors"
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

var errNotFound = errors.New("field not found")

// SignalsFromV1Data creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromV1Data(baseSignal vss.Signal, jsonData []byte) ([]vss.Signal, []error) {
	var retSignals []vss.Signal

	var val any
	var err error
	var errs []error

	val, err = BodyLightsIsAirbagWarningOnFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'BodyLightsIsAirbagWarningOn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "bodyLightsIsAirbagWarningOn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = BodyLockIsLockedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'BodyLockIsLocked': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "bodyLockIsLocked",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = BodyTrunkFrontIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'BodyTrunkFrontIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "bodyTrunkFrontIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = BodyTrunkRearIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'BodyTrunkRearIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "bodyTrunkRearIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinDoorRow1DriverSideIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinDoorRow1DriverSideIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinDoorRow1DriverSideIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinDoorRow1PassengerSideIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinDoorRow1PassengerSideIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinDoorRow1PassengerSideIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinDoorRow2DriverSideIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinDoorRow2DriverSideIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinDoorRow2DriverSideIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinDoorRow2PassengerSideIsOpenFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinDoorRow2PassengerSideIsOpen': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinDoorRow2PassengerSideIsOpen",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow1DriverSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow1DriverSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow1DriverSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow1PassengerSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow1PassengerSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow1PassengerSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow2DriverSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow2DriverSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow2DriverSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow2MiddleIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow2MiddleIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow2MiddleIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow2PassengerSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow2PassengerSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow2PassengerSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow3DriverSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow3DriverSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow3DriverSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CabinSeatRow3PassengerSideIsBeltedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CabinSeatRow3PassengerSideIsBelted': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "cabinSeatRow3PassengerSideIsBelted",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow1WheelLeftTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow1WheelRightTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow2WheelLeftTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow2WheelRightTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow3WeightFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow3Weight': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow3Weight",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow4WeightFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow4Weight': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow4Weight",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow5WeightFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow5Weight': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow5Weight",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisBrakeABSIsWarningOnFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisBrakeABSIsWarningOn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisBrakeABSIsWarningOn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisBrakeCircuit1PressurePrimaryFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisBrakeCircuit1PressurePrimary': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisBrakeCircuit1PressurePrimary",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisBrakeCircuit2PressurePrimaryFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisBrakeCircuit2PressurePrimary': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisBrakeCircuit2PressurePrimary",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisBrakeIsPedalPressedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisBrakeIsPedalPressed': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisBrakeIsPedalPressed",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisBrakePedalPositionFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisBrakePedalPosition': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisBrakePedalPosition",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisParkingBrakeIsEngagedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisParkingBrakeIsEngaged': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisParkingBrakeIsEngaged",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisTireSystemIsWarningOnFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisTireSystemIsWarningOn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisTireSystemIsWarningOn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationAltitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationAltitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationAltitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationHeadingFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationHeading': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationHeading",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLatitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLatitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationLatitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLongitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLongitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationLongitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketHDOPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketHDOP': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "dimoAftermarketHDOP",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = DIMOAftermarketNSATFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'DIMOAftermarketNSAT': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "dimoAftermarketNSAT",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ExteriorAirTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ExteriorAirTemperature': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "exteriorAirTemperature",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = IsIgnitionOnFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'IsIgnitionOn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "isIgnitionOn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = LowVoltageBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'LowVoltageBatteryCurrentVoltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "lowVoltageBatteryCurrentVoltage",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDDTCListFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDDTCList': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdDTCList",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDDistanceWithMILFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDDistanceWithMIL': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdDistanceWithMIL",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDEngineLoadFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDEngineLoad': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdEngineLoad",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDFuelRateFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDFuelRate': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdFuelRate",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDFuelTypeNameFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDFuelTypeName': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdFuelTypeName",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDIsEngineBlockedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDIsEngineBlocked': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdIsEngineBlocked",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDIsPTOActiveFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDIsPTOActive': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdIsPTOActive",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDIsPluggedInFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDIsPluggedIn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdIsPluggedIn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDOilTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDOilTemperature': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdOilTemperature",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDRunTimeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDRunTime': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdRunTime",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDStatusDTCCountFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'OBDStatusDTCCount': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "obdStatusDTCCount",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineDieselExhaustFluidCapacityFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineDieselExhaustFluidCapacity': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineDieselExhaustFluidCapacity",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineDieselExhaustFluidLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineDieselExhaustFluidLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineDieselExhaustFluidLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineECTFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineECT': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineECT",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEOPFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEOP': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineEOP",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineEngineOilLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilRelativeLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineEngineOilRelativeLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineSpeed': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineSpeed",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineTPSFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTPS': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineTPS",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineTorquePercentFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTorquePercent': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineTorquePercent",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAbsoluteLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainFuelSystemAbsoluteLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemAccumulatedConsumptionFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAccumulatedConsumption': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainFuelSystemAccumulatedConsumption",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemRelativeLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemRelativeLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainFuelSystemRelativeLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingIsCharging': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryChargingIsCharging",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingIsChargingCableConnectedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingIsChargingCableConnected': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryChargingIsChargingCableConnected",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingPowerFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingPower': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryChargingPower",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryRangeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryRange': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryRange",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryStateOfChargeCurrent': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryStateOfChargeCurrent",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryStateOfHealthFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryStateOfHealth': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTractionBatteryStateOfHealth",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionCurrentGearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionCurrentGear': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionCurrentGear",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionIsClutchSwitchOperatedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionIsClutchSwitchOperated': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionIsClutchSwitchOperated",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionRetarderActualTorqueFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionRetarderActualTorque': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionRetarderActualTorque",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionRetarderTorqueModeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionRetarderTorqueMode': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionRetarderTorqueMode",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionSelectedGearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionSelectedGear': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionSelectedGear",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionTravelledDistanceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionTravelledDistance",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTypeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainType': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainType",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ServiceTimeToServiceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ServiceTimeToService': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "serviceTimeToService",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = SpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'Speed': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "speed",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

// BodyLightsIsAirbagWarningOnFromV1Data converts the given JSON data to a float64.
func BodyLightsIsAirbagWarningOnFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.347")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToBodyLightsIsAirbagWarningOn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.347': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.347' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'BodyLightsIsAirbagWarningOn'", errNotFound)
	}

	return ret, errs
}

// BodyLockIsLockedFromV1Data converts the given JSON data to a float64.
func BodyLockIsLockedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.538")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToBodyLockIsLocked0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.538': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.538' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'BodyLockIsLocked'", errNotFound)
	}

	return ret, errs
}

// BodyTrunkFrontIsOpenFromV1Data converts the given JSON data to a float64.
func BodyTrunkFrontIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToBodyTrunkFrontIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'BodyTrunkFrontIsOpen'", errNotFound)
	}

	return ret, errs
}

// BodyTrunkRearIsOpenFromV1Data converts the given JSON data to a float64.
func BodyTrunkRearIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToBodyTrunkRearIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'BodyTrunkRearIsOpen'", errNotFound)
	}

	return ret, errs
}

// CabinDoorRow1DriverSideIsOpenFromV1Data converts the given JSON data to a float64.
func CabinDoorRow1DriverSideIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinDoorRow1DriverSideIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinDoorRow1DriverSideIsOpen'", errNotFound)
	}

	return ret, errs
}

// CabinDoorRow1PassengerSideIsOpenFromV1Data converts the given JSON data to a float64.
func CabinDoorRow1PassengerSideIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinDoorRow1PassengerSideIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinDoorRow1PassengerSideIsOpen'", errNotFound)
	}

	return ret, errs
}

// CabinDoorRow2DriverSideIsOpenFromV1Data converts the given JSON data to a float64.
func CabinDoorRow2DriverSideIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinDoorRow2DriverSideIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinDoorRow2DriverSideIsOpen'", errNotFound)
	}

	return ret, errs
}

// CabinDoorRow2PassengerSideIsOpenFromV1Data converts the given JSON data to a float64.
func CabinDoorRow2PassengerSideIsOpenFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.518")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinDoorRow2PassengerSideIsOpen0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.518': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.518' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinDoorRow2PassengerSideIsOpen'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow1DriverSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow1DriverSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow1DriverSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow1DriverSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow1PassengerSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow1PassengerSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow1PassengerSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow1PassengerSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow2DriverSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow2DriverSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow2DriverSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow2DriverSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow2MiddleIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow2MiddleIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow2MiddleIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow2MiddleIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow2PassengerSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow2PassengerSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow2PassengerSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow2PassengerSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow3DriverSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow3DriverSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow3DriverSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow3DriverSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// CabinSeatRow3PassengerSideIsBeltedFromV1Data converts the given JSON data to a float64.
func CabinSeatRow3PassengerSideIsBeltedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.109")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCabinSeatRow3PassengerSideIsBelted0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.109': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.109' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CabinSeatRow3PassengerSideIsBelted'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelLeftTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.960")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.960': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.960' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.965")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.965': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.965' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.961")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.961': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.961' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.966")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.966': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.966' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.962")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.962': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.962' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.967")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.967': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.967' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.963")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.963': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.963' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.968")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.968': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.968' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow3WeightFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow3WeightFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.53")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow3Weight0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.53': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.53' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow3Weight'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow4WeightFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow4WeightFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.54")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow4Weight0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.54': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.54' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow4Weight'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow5WeightFromV1Data converts the given JSON data to a float64.
func ChassisAxleRow5WeightFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.55")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow5Weight0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.55': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.55' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow5Weight'", errNotFound)
	}

	return ret, errs
}

// ChassisBrakeABSIsWarningOnFromV1Data converts the given JSON data to a float64.
func ChassisBrakeABSIsWarningOnFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.313")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisBrakeABSIsWarningOn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.313': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.313' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisBrakeABSIsWarningOn'", errNotFound)
	}

	return ret, errs
}

// ChassisBrakeCircuit1PressurePrimaryFromV1Data converts the given JSON data to a float64.
func ChassisBrakeCircuit1PressurePrimaryFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.355")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisBrakeCircuit1PressurePrimary0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.355': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.355' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisBrakeCircuit1PressurePrimary'", errNotFound)
	}

	return ret, errs
}

// ChassisBrakeCircuit2PressurePrimaryFromV1Data converts the given JSON data to a float64.
func ChassisBrakeCircuit2PressurePrimaryFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.356")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisBrakeCircuit2PressurePrimary0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.356': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.356' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisBrakeCircuit2PressurePrimary'", errNotFound)
	}

	return ret, errs
}

// ChassisBrakeIsPedalPressedFromV1Data converts the given JSON data to a float64.
func ChassisBrakeIsPedalPressedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.36")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisBrakeIsPedalPressed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.36': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.36' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisBrakeIsPedalPressed'", errNotFound)
	}

	return ret, errs
}

// ChassisBrakePedalPositionFromV1Data converts the given JSON data to a float64.
func ChassisBrakePedalPositionFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.482")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisBrakePedalPosition0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.482': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.482' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisBrakePedalPosition'", errNotFound)
	}

	return ret, errs
}

// ChassisParkingBrakeIsEngagedFromV1Data converts the given JSON data to a float64.
func ChassisParkingBrakeIsEngagedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.362")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisParkingBrakeIsEngaged0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.362': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.362' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisParkingBrakeIsEngaged'", errNotFound)
	}

	return ret, errs
}

// ChassisTireSystemIsWarningOnFromV1Data converts the given JSON data to a float64.
func ChassisTireSystemIsWarningOnFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.316")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisTireSystemIsWarningOn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.316': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.316' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisTireSystemIsWarningOn'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationAltitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationAltitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.alt")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationAltitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.alt': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.alt' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationAltitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationHeadingFromV1Data converts the given JSON data to a float64.
func CurrentLocationHeadingFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.dir")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationHeading0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.dir': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.dir' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationHeading'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLatitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationLatitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.lat")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLatitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.lat': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.lat' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLongitudeFromV1Data converts the given JSON data to a float64.
func CurrentLocationLongitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.lon")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLongitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.lon': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.lon' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketHDOPFromV1Data converts the given JSON data to a float64.
func DIMOAftermarketHDOPFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.hdop")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToDIMOAftermarketHDOP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.hdop': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.hdop' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketHDOP'", errNotFound)
	}

	return ret, errs
}

// DIMOAftermarketNSATFromV1Data converts the given JSON data to a float64.
func DIMOAftermarketNSATFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "pos.sat")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToDIMOAftermarketNSAT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.sat': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.sat' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'DIMOAftermarketNSAT'", errNotFound)
	}

	return ret, errs
}

// ExteriorAirTemperatureFromV1Data converts the given JSON data to a float64.
func ExteriorAirTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.97")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToExteriorAirTemperature0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.97': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.97' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.89")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToExteriorAirTemperature1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.89': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.89' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ExteriorAirTemperature'", errNotFound)
	}

	return ret, errs
}

// IsIgnitionOnFromV1Data converts the given JSON data to a float64.
func IsIgnitionOnFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.409")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToIsIgnitionOn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.409': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.409' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.522")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToIsIgnitionOn1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.522': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.522' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'IsIgnitionOn'", errNotFound)
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromV1Data converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.29")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToLowVoltageBatteryCurrentVoltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.29': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.29' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'LowVoltageBatteryCurrentVoltage'", errNotFound)
	}

	return ret, errs
}

// OBDDTCListFromV1Data converts the given JSON data to a string.
func OBDDTCListFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "dtc_codes")
	if result.Exists() && result.Value() != nil {
		if result.IsArray() {
			sliceOBDDTCList := make([]any, len(result.Array()))
			for i, res := range result.Array() {
				v, ok := res.Value().(any)
				if ok {
					sliceOBDDTCList[i] = v
				} else {
					errs = errors.Join(errs, fmt.Errorf("%w, field 'dtc_codes' array element %d is not of type 'any' got '%v' of type '%T'", convert.InvalidTypeError(), i, res.Value(), res.Value()))
				}
			}
			retVal, err := ToOBDDTCList0(jsonData, sliceOBDDTCList)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert ': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'dtc_codes' is not an array", convert.InvalidTypeError()))
		}

	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDDTCList'", errNotFound)
	}

	return ret, errs
}

// OBDDistanceWithMILFromV1Data converts the given JSON data to a float64.
func OBDDistanceWithMILFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.102")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDDistanceWithMIL0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.102': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.102' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDDistanceWithMIL'", errNotFound)
	}

	return ret, errs
}

// OBDEngineLoadFromV1Data converts the given JSON data to a float64.
func OBDEngineLoadFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.39")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDEngineLoad0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.39': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.39' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDEngineLoad'", errNotFound)
	}

	return ret, errs
}

// OBDFuelRateFromV1Data converts the given JSON data to a float64.
func OBDFuelRateFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.116")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDFuelRate0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.116': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.116' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.100")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDFuelRate1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.100': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.100' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDFuelRate'", errNotFound)
	}

	return ret, errs
}

// OBDFuelTypeNameFromV1Data converts the given JSON data to a string.
func OBDFuelTypeNameFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.99")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDFuelTypeName0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.99': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.99' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDFuelTypeName'", errNotFound)
	}

	return ret, errs
}

// OBDIsEngineBlockedFromV1Data converts the given JSON data to a float64.
func OBDIsEngineBlockedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.405")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDIsEngineBlocked0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.405': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.405' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDIsEngineBlocked'", errNotFound)
	}

	return ret, errs
}

// OBDIsPTOActiveFromV1Data converts the given JSON data to a float64.
func OBDIsPTOActiveFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.38")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDIsPTOActive0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.38': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.38' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDIsPTOActive'", errNotFound)
	}

	return ret, errs
}

// OBDIsPluggedInFromV1Data converts the given JSON data to a float64.
func OBDIsPluggedInFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.985")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDIsPluggedIn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.985': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.985' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDIsPluggedIn'", errNotFound)
	}

	return ret, errs
}

// OBDOilTemperatureFromV1Data converts the given JSON data to a float64.
func OBDOilTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.727")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDOilTemperature0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.727': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.727' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDOilTemperature'", errNotFound)
	}

	return ret, errs
}

// OBDRunTimeFromV1Data converts the given JSON data to a float64.
func OBDRunTimeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.107")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDRunTime0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.107': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.107' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDRunTime'", errNotFound)
	}

	return ret, errs
}

// OBDStatusDTCCountFromV1Data converts the given JSON data to a float64.
func OBDStatusDTCCountFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.108")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToOBDStatusDTCCount0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.108': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.108' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDStatusDTCCount'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineDieselExhaustFluidCapacityFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineDieselExhaustFluidCapacityFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.1148")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineDieselExhaustFluidCapacity0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1148': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1148' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.1149")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineDieselExhaustFluidCapacity1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1149': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1149' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineDieselExhaustFluidCapacity'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineDieselExhaustFluidLevelFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineDieselExhaustFluidLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.1150")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineDieselExhaustFluidLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1150': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1150' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.201")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineDieselExhaustFluidLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.201': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.201' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.357")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineDieselExhaustFluidLevel2(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.357': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.357' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineDieselExhaustFluidLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.96")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineECT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.96': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.96' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.115")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineECT1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.115': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.115' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineECT'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEOPFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineEOPFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.728")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEOP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.728': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.728' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEOP'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilLevelFromV1Data converts the given JSON data to a string.
func PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.964")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.964': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.964' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.1187")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1187': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1187' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineEngineOilRelativeLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.964")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilRelativeLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.964': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.964' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.1187")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilRelativeLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1187': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1187' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilRelativeLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.94")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.94': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.94' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.197")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.197': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.197' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineSpeed'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineTPSFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineTPSFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.103")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTPS0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.103': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.103' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.206")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTPS1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.206': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.206' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineTPS'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineTorquePercentFromV1Data converts the given JSON data to a float64.
func PowertrainCombustionEngineTorquePercentFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.519")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTorquePercent0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.519': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.519' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.101")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTorquePercent1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.101': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.101' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineTorquePercent'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemAbsoluteLevelFromV1Data converts the given JSON data to a float64.
func PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.642")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemAbsoluteLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.642': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.642' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.205")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemAbsoluteLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.205': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.205' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemAbsoluteLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemAccumulatedConsumptionFromV1Data converts the given JSON data to a float64.
func PowertrainFuelSystemAccumulatedConsumptionFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.208")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemAccumulatedConsumption0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.208': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.208' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.92")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemAccumulatedConsumption1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.92': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.92' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemAccumulatedConsumption'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemRelativeLevelFromV1Data converts the given JSON data to a float64.
func PowertrainFuelSystemRelativeLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.98")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemRelativeLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.98': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.98' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.207")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemRelativeLevel1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.207': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.207' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemRelativeLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.517")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingIsCharging0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.517': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.517' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingIsCharging'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingCableConnectedFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingCableConnectedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.1191")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingIsChargingCableConnected0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1191': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1191' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingIsChargingCableConnected'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingPowerFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingPowerFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.1190")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingPower0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.1190': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.1190' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingPower'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryRangeFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryRangeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.723")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryRange0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.723': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.723' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.516")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryRange1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.516': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.516' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryRange'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.722")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.722': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.722' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.515")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.515': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.515' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.720")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent2(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.720': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.720' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryStateOfChargeCurrent'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfHealthFromV1Data converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfHealthFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.950")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfHealth0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.950': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.950' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryStateOfHealth'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionCurrentGearFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionCurrentGearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.367")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionCurrentGear0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.367': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.367' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionCurrentGear'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionIsClutchSwitchOperatedFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionIsClutchSwitchOperatedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.35")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionIsClutchSwitchOperated0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.35': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.35' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionIsClutchSwitchOperated'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionRetarderActualTorqueFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionRetarderActualTorqueFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.360")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionRetarderActualTorque0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.360': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.360' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionRetarderActualTorque'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionRetarderTorqueModeFromV1Data converts the given JSON data to a string.
func PowertrainTransmissionRetarderTorqueModeFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.359")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionRetarderTorqueMode0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.359': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.359' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionRetarderTorqueMode'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionSelectedGearFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionSelectedGearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.366")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionSelectedGear0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.366': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.366' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionSelectedGear'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromV1Data converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.645")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.645': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.645' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.114")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.114': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.114' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}

	return ret, errs
}

// PowertrainTypeFromV1Data converts the given JSON data to a string.
func PowertrainTypeFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.99")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainType0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.99': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.99' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.483")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainType1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.483': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.483' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainType'", errNotFound)
	}

	return ret, errs
}

// ServiceTimeToServiceFromV1Data converts the given JSON data to a float64.
func ServiceTimeToServiceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.520")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToServiceTimeToService0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.520': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.520' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ServiceTimeToService'", errNotFound)
	}

	return ret, errs
}

// SpeedFromV1Data converts the given JSON data to a float64.
func SpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "signals.95")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.95': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.95' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "pos.spd")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToSpeed1(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'pos.spd': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'pos.spd' is not of type 'float64' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "signals.210")
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToSpeed2(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'signals.210': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'signals.210' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'Speed'", errNotFound)
	}

	return ret, errs
}
