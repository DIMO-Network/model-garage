// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"strconv"

	"github.com/DIMO-Network/model-garage/pkg/tesla/telemetry/unit"
	"github.com/teslamotors/fleet-telemetry/protos"
	"github.com/DIMO-Network/model-garage/pkg/vss"
)

func ProcessPayload(payload *protos.Payload, subject string, source string) ([]vss.Signal, []error) {
	var out []vss.Signal
	var outErr []error
	{{/* Is it worth it to reuse more variables? */}}

	ts := payload.GetCreatedAt().AsTime()

	for _, d := range payload.GetData() {
		switch d.GetKey() {
		{{- range .Conversions}}
		{{- $teslaField := .TeslaField}}
		case protos.Field_{{.TeslaField}}:
			var tvf {{.GoInputType}}
			switch tv := d.GetValue().Value.(type) {
			case *protos.{{.WrapperName}}:
				tvf = tv.{{.WrapperFieldName}}
			{{- if .Parser}}
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.{{.Parser}}(tv.StringValue)
				if err != nil {
				    outErr = append(outErr, fmt.Errorf("failed to parse string %q for field {{.TeslaField}} into {{.GoInputType}}: %w", tv.StringValue, err))
				    continue
				}
			{{- end}}
			case *protos.Value_Invalid:
				continue
			default:
				{{- if .Parser}}
				outErr = append(outErr, fmt.Errorf("type of {{.TeslaField}} is %T instead of the expected {{.GoInputType}} or string", tv))
				{{- else}}
				outErr = append(outErr, fmt.Errorf("type of {{.TeslaField}} is %T instead of the expected {{.GoInputType}}", tv))
				{{- end}}
				continue
			}
			{{- range .VSSSignals}}
			{{- if .ConvertFunc}}
			utv := unit.{{.ConvertFunc}}(tvf)
			if res, err := Convert{{$teslaField}}To{{.GoVSSName}}(utv); err != nil { {{/* Do we have any need for these inner functions when unit conversion is automatic? */}}
			{{- else}}
			if res, err := Convert{{$teslaField}}To{{.GoVSSName}}(tvf); err != nil {
			{{- end}}
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					Subject: subject,
					Name: "{{.JSONName}}",
					Timestamp: ts,
					Source: source,
				}
				sig.SetValue(res) {{/* Would be nice to skip the runtime check, since we know the type. */}}
				out = append(out, sig)
			}
			{{- end}}
		{{- end}}
		} {{/* Unclear whether we want to warn about fields we don't handle. */}}
	}

	return out, outErr
}
