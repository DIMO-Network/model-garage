// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package telemetry

import (
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/tesla/telemetry/parse"
	"github.com/DIMO-Network/model-garage/pkg/tesla/telemetry/unit"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/teslamotors/fleet-telemetry/protos"
)

func ProcessPayload(payload *protos.Payload, tokenID uint32, source string) ([]vss.Signal, []error) {
	var out []vss.Signal
	var outErr []error

	ts := payload.GetCreatedAt().AsTime()

	for _, d := range payload.GetData() {
		switch d.GetKey() {
		case protos.Field_Location:
			var tvf *protos.LocationValue
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_LocationValue:
				tvf = tv.LocationValue
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of Location is %T instead of the expected *protos.LocationValue", tv))
				continue
			}
			if res, err := ConvertLocationToCurrentLocationCoordinates(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "currentLocationCoordinates",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_DetailedChargeState:
			var tvf protos.DetailedChargeStateValue
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DetailedChargeStateValue:
				tvf = tv.DetailedChargeStateValue
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of DetailedChargeState is %T instead of the expected protos.DetailedChargeStateValue", tv))
				continue
			}
			if res, err := ConvertDetailedChargeStateToPowertrainTractionBatteryChargingIsCharging(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingIsCharging",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
			if res, err := ConvertDetailedChargeStateToPowertrainTractionBatteryChargingIsChargingCableConnected(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingIsChargingCableConnected",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_ACChargingPower:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field ACChargingPower into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of ACChargingPower is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.KilowattsToWatts(tvf)
			if res, err := ConvertACChargingPowerToPowertrainTractionBatteryCurrentPower(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryCurrentPower",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_DCChargingPower:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field DCChargingPower into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of DCChargingPower is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.KilowattsToWatts(tvf)
			if res, err := ConvertDCChargingPowerToPowertrainTractionBatteryCurrentPower(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryCurrentPower",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_DCChargingEnergyIn:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field DCChargingEnergyIn into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of DCChargingEnergyIn is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertDCChargingEnergyInToPowertrainTractionBatteryChargingAddedEnergy(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingAddedEnergy",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_EnergyRemaining:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field EnergyRemaining into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of EnergyRemaining is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertEnergyRemainingToPowertrainTractionBatteryStateOfChargeCurrentEnergy(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryStateOfChargeCurrentEnergy",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_Soc:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field Soc into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of Soc is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertSocToPowertrainTractionBatteryStateOfChargeCurrent(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryStateOfChargeCurrent",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_TpmsPressureFl:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field TpmsPressureFl into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of TpmsPressureFl is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.AtmospheresToKilopascals(tvf)
			if res, err := ConvertTpmsPressureFlToChassisAxleRow1WheelLeftTirePressure(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "chassisAxleRow1WheelLeftTirePressure",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_TpmsPressureFr:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field TpmsPressureFr into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of TpmsPressureFr is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.AtmospheresToKilopascals(tvf)
			if res, err := ConvertTpmsPressureFrToChassisAxleRow1WheelRightTirePressure(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "chassisAxleRow1WheelRightTirePressure",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_TpmsPressureRl:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field TpmsPressureRl into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of TpmsPressureRl is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.AtmospheresToKilopascals(tvf)
			if res, err := ConvertTpmsPressureRlToChassisAxleRow2WheelLeftTirePressure(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "chassisAxleRow2WheelLeftTirePressure",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_TpmsPressureRr:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field TpmsPressureRr into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of TpmsPressureRr is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.AtmospheresToKilopascals(tvf)
			if res, err := ConvertTpmsPressureRrToChassisAxleRow2WheelRightTirePressure(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "chassisAxleRow2WheelRightTirePressure",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_OutsideTemp:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field OutsideTemp into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of OutsideTemp is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertOutsideTempToExteriorAirTemperature(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "exteriorAirTemperature",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_EstBatteryRange:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field EstBatteryRange into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of EstBatteryRange is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.MilesToKilometers(tvf)
			if res, err := ConvertEstBatteryRangeToPowertrainRange(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainRange",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_ChargeLimitSoc:
			var tvf int32
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_IntValue:
				tvf = tv.IntValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Int32(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field ChargeLimitSoc into int32: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of ChargeLimitSoc is %T instead of the expected int32 or string", tv))
				continue
			}
			if res, err := ConvertChargeLimitSocToPowertrainTractionBatteryChargingChargeLimit(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingChargeLimit",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_Odometer:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field Odometer into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of Odometer is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.MilesToKilometers(tvf)
			if res, err := ConvertOdometerToPowertrainTransmissionTravelledDistance(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTransmissionTravelledDistance",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_VehicleSpeed:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field VehicleSpeed into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of VehicleSpeed is %T instead of the expected float64 or string", tv))
				continue
			}
			utv := unit.MilesPerHourToKilometersPerHour(tvf)
			if res, err := ConvertVehicleSpeedToSpeed(utv); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "speed",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_DoorState:
			var tvf *protos.Doors
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoorValue:
				tvf = tv.DoorValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Doors(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field DoorState into *protos.Doors: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of DoorState is %T instead of the expected *protos.Doors or string", tv))
				continue
			}
			if res, err := ConvertDoorStateToCabinDoorRow1DriverSideIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow1DriverSideIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
			if res, err := ConvertDoorStateToCabinDoorRow1PassengerSideIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow1PassengerSideIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
			if res, err := ConvertDoorStateToCabinDoorRow2DriverSideIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow2DriverSideIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
			if res, err := ConvertDoorStateToCabinDoorRow2PassengerSideIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow2PassengerSideIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_FdWindow:
			var tvf protos.WindowState
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_WindowStateValue:
				tvf = tv.WindowStateValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.WindowState(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field FdWindow into protos.WindowState: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of FdWindow is %T instead of the expected protos.WindowState or string", tv))
				continue
			}
			if res, err := ConvertFdWindowToCabinDoorRow1DriverSideWindowIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow1DriverSideWindowIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_FpWindow:
			var tvf protos.WindowState
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_WindowStateValue:
				tvf = tv.WindowStateValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.WindowState(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field FpWindow into protos.WindowState: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of FpWindow is %T instead of the expected protos.WindowState or string", tv))
				continue
			}
			if res, err := ConvertFpWindowToCabinDoorRow1PassengerSideWindowIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow1PassengerSideWindowIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_RdWindow:
			var tvf protos.WindowState
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_WindowStateValue:
				tvf = tv.WindowStateValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.WindowState(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field RdWindow into protos.WindowState: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of RdWindow is %T instead of the expected protos.WindowState or string", tv))
				continue
			}
			if res, err := ConvertRdWindowToCabinDoorRow2DriverSideWindowIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow2DriverSideWindowIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_RpWindow:
			var tvf protos.WindowState
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_WindowStateValue:
				tvf = tv.WindowStateValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.WindowState(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field RpWindow into protos.WindowState: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of RpWindow is %T instead of the expected protos.WindowState or string", tv))
				continue
			}
			if res, err := ConvertRpWindowToCabinDoorRow2PassengerSideWindowIsOpen(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "cabinDoorRow2PassengerSideWindowIsOpen",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_ChargeAmps:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field ChargeAmps into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of ChargeAmps is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertChargeAmpsToPowertrainTractionBatteryChargingChargeCurrentAC(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingChargeCurrentAC",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		case protos.Field_ChargerVoltage:
			var tvf float64
			switch tv := d.GetValue().Value.(type) {
			case *protos.Value_DoubleValue:
				tvf = tv.DoubleValue
			case *protos.Value_StringValue:
				var err error
				tvf, err = parse.Double(tv.StringValue)
				if err != nil {
					outErr = append(outErr, fmt.Errorf("failed to parse string %q for field ChargerVoltage into float64: %w", tv.StringValue, err))
					continue
				}
			case *protos.Value_Invalid:
				continue
			default:
				outErr = append(outErr, fmt.Errorf("type of ChargerVoltage is %T instead of the expected float64 or string", tv))
				continue
			}
			if res, err := ConvertChargerVoltageToPowertrainTractionBatteryChargingChargeVoltageUnknownType(tvf); err != nil {
				outErr = append(outErr, err)
			} else {
				sig := vss.Signal{
					TokenID:   tokenID,
					Name:      "powertrainTractionBatteryChargingChargeVoltageUnknownType",
					Timestamp: ts,
					Source:    source,
				}
				sig.SetValue(res)
				out = append(out, sig)
			}
		}
	}

	return out, outErr
}
