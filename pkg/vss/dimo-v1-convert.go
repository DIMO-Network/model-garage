// Code generated by "model-garage" DO NOT EDIT.
package vss

import (
	"errors"
	"fmt"
	"time"

	"github.com/tidwall/gjson"
)

// SignalsFromV1Data creates a slice of Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromV1Data(tokenID uint32, timestamp time.Time, jsonData []byte) ([]Signal, error) {
	var retSignals []Signal

	var val any
	var err error
	var errs error

	val, err = VehicleChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleChassisAxleRow1WheelLeftTirePressure': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Chassis_Axle_Row1_Wheel_Left_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleChassisAxleRow1WheelRightTirePressure': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Chassis_Axle_Row1_Wheel_Right_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleChassisAxleRow2WheelLeftTirePressure': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Chassis_Axle_Row2_Wheel_Left_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleChassisAxleRow2WheelRightTirePressure': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Chassis_Axle_Row2_Wheel_Right_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleCurrentLocationAltitudeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleCurrentLocationAltitude': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_CurrentLocation_Altitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleCurrentLocationLatitudeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleCurrentLocationLatitude': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_CurrentLocation_Latitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleCurrentLocationLongitudeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleCurrentLocationLongitude': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_CurrentLocation_Longitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleCurrentLocationTimestampFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleCurrentLocationTimestamp': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_CurrentLocation_Timestamp",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleExteriorAirTemperatureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleExteriorAirTemperature': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Exterior_AirTemperature",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleLowVoltageBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleLowVoltageBatteryCurrentVoltage': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_LowVoltageBattery_CurrentVoltage",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleOBDBarometricPressureFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleOBDBarometricPressure': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_OBD_BarometricPressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleOBDEngineLoadFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleOBDEngineLoad': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_OBD_EngineLoad",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleOBDIntakeTempFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleOBDIntakeTemp': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_OBD_IntakeTemp",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleOBDRunTimeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleOBDRunTime': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_OBD_RunTime",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainCombustionEngineECTFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainCombustionEngineECT': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_CombustionEngine_ECT",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainCombustionEngineEngineOilLevel': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_CombustionEngine_EngineOilLevel",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainCombustionEngineSpeedFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainCombustionEngineSpeed': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_CombustionEngine_Speed",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainCombustionEngineTPSFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainCombustionEngineTPS': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_CombustionEngine_TPS",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainFuelSystemAbsoluteLevel': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_FuelSystem_AbsoluteLevel",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainFuelSystemSupportedFuelTypes': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_FuelSystem_SupportedFuelTypes",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainRangeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainRange': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_Range",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainTractionBatteryChargingChargeLimit': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_TractionBattery_Charging_ChargeLimit",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainTractionBatteryChargingIsCharging': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_TractionBattery_Charging_IsCharging",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTractionBatteryGrossCapacityFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainTractionBatteryGrossCapacity': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_TractionBattery_GrossCapacity",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainTractionBatteryStateOfChargeCurrent': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_TractionBattery_StateOfCharge_Current",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTransmissionTravelledDistanceFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainTransmissionTravelledDistance': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_Transmission_TravelledDistance",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehiclePowertrainTypeFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehiclePowertrainType': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Powertrain_Type",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleSpeedFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleSpeed': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_Speed",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleVehicleIdentificationBrandFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleVehicleIdentificationBrand': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_VehicleIdentification_Brand",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleVehicleIdentificationModelFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleVehicleIdentificationModel': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_VehicleIdentification_Model",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleVehicleIdentificationYearFromV1Data(jsonData)
	if err != nil {
		errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleVehicleIdentificationYear': %w", err))
	} else {
		sig := Signal{
			Name:      "Vehicle_VehicleIdentification_Year",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

// VehicleChassisAxleRow1WheelLeftTirePressureFromData converts the given JSON data to a float64.
func VehicleChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontLeft")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleChassisAxleRow1WheelLeftTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleChassisAxleRow1WheelRightTirePressureFromData converts the given JSON data to a float64.
func VehicleChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontRight")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleChassisAxleRow1WheelRightTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleChassisAxleRow2WheelLeftTirePressureFromData converts the given JSON data to a float64.
func VehicleChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backLeft")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleChassisAxleRow2WheelLeftTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleChassisAxleRow2WheelRightTirePressureFromData converts the given JSON data to a float64.
func VehicleChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backRight")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleChassisAxleRow2WheelRightTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleCurrentLocationAltitudeFromData converts the given JSON data to a float64.
func VehicleCurrentLocationAltitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.altitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleCurrentLocationAltitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.altitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.altitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleCurrentLocationLatitudeFromData converts the given JSON data to a float64.
func VehicleCurrentLocationLatitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.latitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleCurrentLocationLatitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.latitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.latitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleCurrentLocationLongitudeFromData converts the given JSON data to a float64.
func VehicleCurrentLocationLongitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.longitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleCurrentLocationLongitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.longitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.longitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleCurrentLocationTimestampFromData converts the given JSON data to a float64.
func VehicleCurrentLocationTimestampFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.timestamp")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehicleCurrentLocationTimestamp0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.timestamp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.timestamp' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.timestamp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleCurrentLocationTimestamp1(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.timestamp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.timestamp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleExteriorAirTemperatureFromData converts the given JSON data to a float64.
func VehicleExteriorAirTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.ambientTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleExteriorAirTemperature0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.ambientTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.ambientTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleLowVoltageBatteryCurrentVoltageFromData converts the given JSON data to a float64.
func VehicleLowVoltageBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryVoltage")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleLowVoltageBatteryCurrentVoltage0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryVoltage': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryVoltage' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleOBDBarometricPressureFromData converts the given JSON data to a float64.
func VehicleOBDBarometricPressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.barometricPressure")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleOBDBarometricPressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.barometricPressure': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.barometricPressure' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleOBDEngineLoadFromData converts the given JSON data to a float64.
func VehicleOBDEngineLoadFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineLoad")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleOBDEngineLoad0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineLoad': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineLoad' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleOBDIntakeTempFromData converts the given JSON data to a float64.
func VehicleOBDIntakeTempFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.intakeTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleOBDIntakeTemp0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.intakeTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.intakeTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleOBDRunTimeFromData converts the given JSON data to a float64.
func VehicleOBDRunTimeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.runTime")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleOBDRunTime0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.runTime': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.runTime' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainCombustionEngineECTFromData converts the given JSON data to a float64.
func VehiclePowertrainCombustionEngineECTFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.coolantTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainCombustionEngineECT0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.coolantTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.coolantTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainCombustionEngineEngineOilLevelFromData converts the given JSON data to a string.
func VehiclePowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oil")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainCombustionEngineEngineOilLevel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oil': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oil' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainCombustionEngineSpeedFromData converts the given JSON data to a float64.
func VehiclePowertrainCombustionEngineSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineSpeed")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainCombustionEngineSpeed0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineSpeed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainCombustionEngineTPSFromData converts the given JSON data to a float64.
func VehiclePowertrainCombustionEngineTPSFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.throttlePosition")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainCombustionEngineTPS0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.throttlePosition': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.throttlePosition' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainFuelSystemAbsoluteLevelFromData converts the given JSON data to a float64.
func VehiclePowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelPercentRemaining")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainFuelSystemAbsoluteLevel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelPercentRemaining': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelPercentRemaining' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainFuelSystemSupportedFuelTypesFromData converts the given JSON data to a string.
func VehiclePowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehiclePowertrainFuelSystemSupportedFuelTypes0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainRangeFromData converts the given JSON data to a float64.
func VehiclePowertrainRangeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.range")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainRange0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.range': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.range' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTractionBatteryChargingChargeLimitFromData converts the given JSON data to a float64.
func VehiclePowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.chargeLimit")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainTractionBatteryChargingChargeLimit0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.chargeLimit': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.chargeLimit' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTractionBatteryChargingIsChargingFromData converts the given JSON data to a float64.
func VehiclePowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charging")
	if result.Exists() {
		val, ok := result.Value().(bool)
		if ok {
			retVal, err := ToVehiclePowertrainTractionBatteryChargingIsCharging0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charging': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charging' is not of type 'bool' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTractionBatteryGrossCapacityFromData converts the given JSON data to a float64.
func VehiclePowertrainTractionBatteryGrossCapacityFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryCapacity")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainTractionBatteryGrossCapacity0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryCapacity': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryCapacity' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTractionBatteryStateOfChargeCurrentFromData converts the given JSON data to a float64.
func VehiclePowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.soc")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainTractionBatteryStateOfChargeCurrent0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.soc': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.soc' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTransmissionTravelledDistanceFromData converts the given JSON data to a float64.
func VehiclePowertrainTransmissionTravelledDistanceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.odometer")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehiclePowertrainTransmissionTravelledDistance0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.odometer': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.odometer' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehiclePowertrainTypeFromData converts the given JSON data to a string.
func VehiclePowertrainTypeFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehiclePowertrainType0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleSpeedFromData converts the given JSON data to a float64.
func VehicleSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.speed")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleSpeed0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.speed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.speed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleVehicleIdentificationBrandFromData converts the given JSON data to a string.
func VehicleVehicleIdentificationBrandFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.make")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehicleVehicleIdentificationBrand0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.make': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.make' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleVehicleIdentificationModelFromData converts the given JSON data to a string.
func VehicleVehicleIdentificationModelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.model")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehicleVehicleIdentificationModel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.model': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.model' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}

// VehicleVehicleIdentificationYearFromData converts the given JSON data to a float64.
func VehicleVehicleIdentificationYearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.year")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleVehicleIdentificationYear0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.year': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.year' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	return ret, errs
}
