// Code generated by "model-garage" DO NOT EDIT.
package vss

import (
	"errors"
	"fmt"
	"time"

	"github.com/tidwall/gjson"
)

var errNotFound = errors.New("field not found")

// SignalsFromV1Data creates a slice of Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromV1Data(tokenID uint32, timestamp time.Time, jsonData []byte) ([]Signal, error) {
	var retSignals []Signal

	var val any
	var err error
	var errs error

	val, err = ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Chassis_Axle_Row1_Wheel_Left_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Chassis_Axle_Row1_Wheel_Right_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Chassis_Axle_Row2_Wheel_Left_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Chassis_Axle_Row2_Wheel_Right_Tire_Pressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationAltitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'CurrentLocationAltitude': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "CurrentLocation_Altitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLatitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'CurrentLocationLatitude': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "CurrentLocation_Latitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLongitudeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'CurrentLocationLongitude': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "CurrentLocation_Longitude",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationTimestampFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'CurrentLocationTimestamp': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "CurrentLocation_Timestamp",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ExteriorAirTemperatureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'ExteriorAirTemperature': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Exterior_AirTemperature",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = LowVoltageBatteryCurrentVoltageFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'LowVoltageBatteryCurrentVoltage': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "LowVoltageBattery_CurrentVoltage",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDBarometricPressureFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'OBDBarometricPressure': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "OBD_BarometricPressure",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDEngineLoadFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'OBDEngineLoad': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "OBD_EngineLoad",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDIntakeTempFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'OBDIntakeTemp': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "OBD_IntakeTemp",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = OBDRunTimeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'OBDRunTime': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "OBD_RunTime",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineECTFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineECT': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_CombustionEngine_ECT",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEngineOilLevel': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_CombustionEngine_EngineOilLevel",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineMAFFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineMAF': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_CombustionEngine_MAF",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineSpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineSpeed': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_CombustionEngine_Speed",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineTPSFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineTPS': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_CombustionEngine_TPS",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAbsoluteLevel': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_FuelSystem_AbsoluteLevel",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemSupportedFuelTypes': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_FuelSystem_SupportedFuelTypes",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainRangeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainRange': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_Range",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingChargeLimit': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_TractionBattery_Charging_ChargeLimit",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryChargingIsCharging': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_TractionBattery_Charging_IsCharging",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryGrossCapacityFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryGrossCapacity': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_TractionBattery_GrossCapacity",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainTractionBatteryStateOfChargeCurrent': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_TractionBattery_StateOfCharge_Current",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionTravelledDistanceFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_Transmission_TravelledDistance",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTypeFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'PowertrainType': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Powertrain_Type",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = SpeedFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'Speed': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "Speed",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleIdentificationBrandFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleIdentificationBrand': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "VehicleIdentification_Brand",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleIdentificationModelFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleIdentificationModel': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "VehicleIdentification_Model",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = VehicleIdentificationYearFromV1Data(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = errors.Join(errs, fmt.Errorf("failed to get 'VehicleIdentificationYear': %w", err))
		}
	} else {
		sig := Signal{
			Name:      "VehicleIdentification_Year",
			TokenID:   tokenID,
			Timestamp: timestamp,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

// ChassisAxleRow1WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontLeft")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.frontRight")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.frontRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.frontRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backLeft")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backLeft': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.tires.backRight")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.tires.backRight': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.tires.backRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationAltitudeFromData converts the given JSON data to a float64.
func CurrentLocationAltitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.altitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationAltitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.altitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.altitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationAltitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLatitudeFromData converts the given JSON data to a float64.
func CurrentLocationLatitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.latitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLatitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.latitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.latitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLongitudeFromData converts the given JSON data to a float64.
func CurrentLocationLongitudeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.longitude")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationLongitude0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.longitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.longitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationTimestampFromData converts the given JSON data to a float64.
func CurrentLocationTimestampFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.timestamp")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCurrentLocationTimestamp0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.timestamp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.timestamp' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}
	result = gjson.GetBytes(jsonData, "data.timestamp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToCurrentLocationTimestamp1(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.timestamp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.timestamp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationTimestamp'", errNotFound)
	}

	return ret, errs
}

// ExteriorAirTemperatureFromData converts the given JSON data to a float64.
func ExteriorAirTemperatureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.ambientTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToExteriorAirTemperature0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.ambientTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.ambientTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ExteriorAirTemperature'", errNotFound)
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromData converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryVoltage")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToLowVoltageBatteryCurrentVoltage0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryVoltage': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryVoltage' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'LowVoltageBatteryCurrentVoltage'", errNotFound)
	}

	return ret, errs
}

// OBDBarometricPressureFromData converts the given JSON data to a float64.
func OBDBarometricPressureFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.barometricPressure")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDBarometricPressure0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.barometricPressure': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.barometricPressure' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDBarometricPressure'", errNotFound)
	}

	return ret, errs
}

// OBDEngineLoadFromData converts the given JSON data to a float64.
func OBDEngineLoadFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineLoad")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDEngineLoad0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineLoad': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineLoad' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDEngineLoad'", errNotFound)
	}

	return ret, errs
}

// OBDIntakeTempFromData converts the given JSON data to a float64.
func OBDIntakeTempFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.intakeTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDIntakeTemp0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.intakeTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.intakeTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDIntakeTemp'", errNotFound)
	}

	return ret, errs
}

// OBDRunTimeFromData converts the given JSON data to a float64.
func OBDRunTimeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.runTime")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToOBDRunTime0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.runTime': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.runTime' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'OBDRunTime'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.coolantTemp")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineECT0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.coolantTemp': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.coolantTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineECT'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilLevelFromData converts the given JSON data to a string.
func PowertrainCombustionEngineEngineOilLevelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.oil")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEngineOilLevel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.oil': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.oil' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEngineOilLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineMAFFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineMAFFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.maf")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineMAF0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.maf': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.maf' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineMAF'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.engineSpeed")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.engineSpeed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.engineSpeed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineSpeed'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineTPSFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineTPSFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.throttlePosition")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainCombustionEngineTPS0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.throttlePosition': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.throttlePosition' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineTPS'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemAbsoluteLevelFromData converts the given JSON data to a float64.
func PowertrainFuelSystemAbsoluteLevelFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelPercentRemaining")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainFuelSystemAbsoluteLevel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelPercentRemaining': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelPercentRemaining' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemAbsoluteLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemSupportedFuelTypesFromData converts the given JSON data to a string.
func PowertrainFuelSystemSupportedFuelTypesFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemSupportedFuelTypes0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemSupportedFuelTypes'", errNotFound)
	}

	return ret, errs
}

// PowertrainRangeFromData converts the given JSON data to a float64.
func PowertrainRangeFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.range")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainRange0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.range': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.range' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainRange'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingChargeLimitFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeLimitFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.chargeLimit")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingChargeLimit0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.chargeLimit': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.chargeLimit' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingChargeLimit'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.charging")
	if result.Exists() {
		val, ok := result.Value().(bool)
		if ok {
			retVal, err := ToPowertrainTractionBatteryChargingIsCharging0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.charging': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.charging' is not of type 'bool' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryChargingIsCharging'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryGrossCapacityFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryGrossCapacityFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.batteryCapacity")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryGrossCapacity0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.batteryCapacity': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.batteryCapacity' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryGrossCapacity'", errNotFound)
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.soc")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTractionBatteryStateOfChargeCurrent0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.soc': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.soc' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTractionBatteryStateOfChargeCurrent'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromData converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.odometer")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.odometer': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.odometer' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}

	return ret, errs
}

// PowertrainTypeFromData converts the given JSON data to a string.
func PowertrainTypeFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.fuelType")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainType0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.fuelType': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainType'", errNotFound)
	}

	return ret, errs
}

// SpeedFromData converts the given JSON data to a float64.
func SpeedFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.speed")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToSpeed0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.speed': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.speed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'Speed'", errNotFound)
	}

	return ret, errs
}

// VehicleIdentificationBrandFromData converts the given JSON data to a string.
func VehicleIdentificationBrandFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.make")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehicleIdentificationBrand0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.make': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.make' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'VehicleIdentificationBrand'", errNotFound)
	}

	return ret, errs
}

// VehicleIdentificationModelFromData converts the given JSON data to a string.
func VehicleIdentificationModelFromV1Data(jsonData []byte) (ret string, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.model")
	if result.Exists() {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToVehicleIdentificationModel0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.model': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.model' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'VehicleIdentificationModel'", errNotFound)
	}

	return ret, errs
}

// VehicleIdentificationYearFromData converts the given JSON data to a float64.
func VehicleIdentificationYearFromV1Data(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	result = gjson.GetBytes(jsonData, "data.year")
	if result.Exists() {
		val, ok := result.Value().(float64)
		if ok {
			retVal, err := ToVehicleIdentificationYear0(val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.year': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.year' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'VehicleIdentificationYear'", errNotFound)
	}

	return ret, errs
}
