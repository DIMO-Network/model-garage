// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package convert

import (
	"errors"
	"fmt"

	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

// errInvalidType is returned when a field is not of the expected type or not found.
var errInvalidType = errors.New("invalid type")

// IsInvalidType returns true if the error is of type errInvalidType.
func IsInvalidType(err error) bool {
	return errors.Is(err, errInvalidType)
}

// SignalsFromData converts the given JSON data to a slice of signals.
func SignalsFromV2Data(originalDoc []byte, baseSignal vss.Signal, signalName string, sigResult gjson.Result) ([]vss.Signal, error) {
	valResult := sigResult.Get("value")
	if !valResult.Exists() {
		return nil, errors.New("value field not found")
	}
	ret := make([]vss.Signal, 0)
	var retErrs error

	switch signalName {
	case "altitude":
		val0, err := CurrentLocationAltitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'altitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationAltitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ambientAirTemp":
		val0, err := ExteriorAirTemperatureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ambientAirTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "exteriorAirTemperature",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ambientTemp":
		val0, err := ExteriorAirTemperatureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ambientTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "exteriorAirTemperature",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "barometricPressure":
		val0, err := OBDBarometricPressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'barometricPressure': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdBarometricPressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "batteryCapacity":
		val0, err := PowertrainTractionBatteryGrossCapacityFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'batteryCapacity': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryGrossCapacity",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "batteryVoltage":
		val0, err := LowVoltageBatteryCurrentVoltageFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'batteryVoltage': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "lowVoltageBatteryCurrentVoltage",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "chargeLimit":
		val0, err := PowertrainTractionBatteryChargingChargeLimitFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'chargeLimit': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryChargingChargeLimit",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "charger.power":
		val0, err := PowertrainTractionBatteryCurrentPowerFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'charger.power': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryCurrentPower",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "charging":
		val0, err := PowertrainTractionBatteryChargingIsChargingFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'charging': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryChargingIsCharging",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "coolantTemp":
		val0, err := PowertrainCombustionEngineECTFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'coolantTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineECT",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "engineLoad":
		val0, err := OBDEngineLoadFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'engineLoad': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdEngineLoad",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "engineSpeed":
		val0, err := PowertrainCombustionEngineSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'engineSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelLevel":
		val0, err := PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelLevel': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemRelativeLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelPercentRemaining":
		val0, err := PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelPercentRemaining': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemRelativeLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "fuelType":
		val0, err := PowertrainFuelSystemSupportedFuelTypesFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelType': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainFuelSystemSupportedFuelTypes",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
		val1, err := PowertrainTypeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'fuelType': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainType",
			}
			sig.SetValue(val1)
			ret = append(ret, sig)
		}
	case "hdop":
		val0, err := DIMOAftermarketHDOPFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'hdop': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketHDOP",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "intakeTemp":
		val0, err := OBDIntakeTempFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'intakeTemp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdIntakeTemp",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "isRedacted":
		val0, err := CurrentLocationIsRedactedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'isRedacted': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationIsRedacted",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "latitude":
		val0, err := CurrentLocationLatitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'latitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationLatitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "longitude":
		val0, err := CurrentLocationLongitudeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'longitude': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationLongitude",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "maf":
		val0, err := PowertrainCombustionEngineMAFFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'maf': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineMAF",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "make":
		val0, err := VehicleIdentificationBrandFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'make': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "vehicleIdentificationBrand",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "model":
		val0, err := VehicleIdentificationModelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'model': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "vehicleIdentificationModel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "nsat":
		val0, err := DIMOAftermarketNSATFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'nsat': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketNSAT",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "odometer":
		val0, err := PowertrainTransmissionTravelledDistanceFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'odometer': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTransmissionTravelledDistance",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "oil":
		val0, err := PowertrainCombustionEngineEngineOilLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oil': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineEngineOilLevel",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
		val1, err := PowertrainCombustionEngineEngineOilRelativeLevelFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'oil': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineEngineOilRelativeLevel",
			}
			sig.SetValue(val1)
			ret = append(ret, sig)
		}
	case "range":
		val0, err := PowertrainRangeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'range': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainRange",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "rpm":
		val0, err := PowertrainCombustionEngineSpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'rpm': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineSpeed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "runTime":
		val0, err := OBDRunTimeFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'runTime': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "obdRunTime",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "soc":
		val0, err := PowertrainTractionBatteryStateOfChargeCurrentFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'soc': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainTractionBatteryStateOfChargeCurrent",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "speed":
		val0, err := SpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'speed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "speed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "ssid":
		val0, err := DIMOAftermarketSSIDFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'ssid': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketSSID",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "throttlePosition":
		val0, err := PowertrainCombustionEngineTPSFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'throttlePosition': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "powertrainCombustionEngineTPS",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "timestamp":
		val0, err := CurrentLocationTimestampFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'timestamp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationTimestamp",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
		val1, err := CurrentLocationTimestampFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'timestamp': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "currentLocationTimestamp",
			}
			sig.SetValue(val1)
			ret = append(ret, sig)
		}
	case "tires.backLeft":
		val0, err := ChassisAxleRow2WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.backLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.backRight":
		val0, err := ChassisAxleRow2WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.backRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow2WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.frontLeft":
		val0, err := ChassisAxleRow1WheelLeftTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.frontLeft': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelLeftTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "tires.frontRight":
		val0, err := ChassisAxleRow1WheelRightTirePressureFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'tires.frontRight': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "chassisAxleRow1WheelRightTirePressure",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "vehicleSpeed":
		val0, err := SpeedFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'vehicleSpeed': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "speed",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wifi.ssid":
		val0, err := DIMOAftermarketSSIDFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wifi.ssid': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketSSID",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wifi.wpaState":
		val0, err := DIMOAftermarketWPAStateFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wifi.wpaState': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketWPAState",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "wpa_state":
		val0, err := DIMOAftermarketWPAStateFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'wpa_state': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "dimoAftermarketWPAState",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	case "year":
		val0, err := VehicleIdentificationYearFromV2Data(originalDoc, valResult)
		if err != nil {
			retErrs = errors.Join(retErrs, fmt.Errorf("failed to convert 'year': %w", err))
		} else {
			sig := vss.Signal{
				TokenID:   baseSignal.TokenID,
				Timestamp: baseSignal.Timestamp,
				Source:    baseSignal.Source,
				Name:      "vehicleIdentificationYear",
			}
			sig.SetValue(val0)
			ret = append(ret, sig)
		}
	default:
		// do nothing
	}
	return ret, retErrs
}

// ChassisAxleRow1WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelLeftTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.frontLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.frontLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow1WheelRightTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.frontRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.frontRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelLeftTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.backLeft': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.backLeft' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromData converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToChassisAxleRow2WheelRightTirePressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'tires.backRight': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'tires.backRight' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationAltitudeFromData converts the given JSON data to a float64.
func CurrentLocationAltitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationAltitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'altitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'altitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationIsRedactedFromData converts the given JSON data to a float64.
func CurrentLocationIsRedactedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(bool)
	if ok {
		ret, err = ToCurrentLocationIsRedacted0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'isRedacted': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'isRedacted' is not of type 'bool' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationLatitudeFromData converts the given JSON data to a float64.
func CurrentLocationLatitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationLatitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'latitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'latitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationLongitudeFromData converts the given JSON data to a float64.
func CurrentLocationLongitudeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationLongitude0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'longitude': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'longitude' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// CurrentLocationTimestampFromData converts the given JSON data to a float64.
func CurrentLocationTimestampFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToCurrentLocationTimestamp0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'timestamp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'timestamp' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToCurrentLocationTimestamp1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'timestamp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'timestamp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketHDOPFromData converts the given JSON data to a float64.
func DIMOAftermarketHDOPFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToDIMOAftermarketHDOP0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'hdop': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'hdop' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketNSATFromData converts the given JSON data to a float64.
func DIMOAftermarketNSATFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToDIMOAftermarketNSAT0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'nsat': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'nsat' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketSSIDFromData converts the given JSON data to a string.
func DIMOAftermarketSSIDFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketSSID0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ssid': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ssid' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketSSID1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wifi.ssid': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wifi.ssid' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// DIMOAftermarketWPAStateFromData converts the given JSON data to a string.
func DIMOAftermarketWPAStateFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketWPAState0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wpa_state': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wpa_state' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(string)
	if ok {
		ret, err = ToDIMOAftermarketWPAState1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'wifi.wpaState': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'wifi.wpaState' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// ExteriorAirTemperatureFromData converts the given JSON data to a float64.
func ExteriorAirTemperatureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToExteriorAirTemperature0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ambientAirTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ambientAirTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToExteriorAirTemperature1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'ambientTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'ambientTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromData converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToLowVoltageBatteryCurrentVoltage0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'batteryVoltage': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'batteryVoltage' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDBarometricPressureFromData converts the given JSON data to a float64.
func OBDBarometricPressureFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDBarometricPressure0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'barometricPressure': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'barometricPressure' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDEngineLoadFromData converts the given JSON data to a float64.
func OBDEngineLoadFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDEngineLoad0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'engineLoad': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'engineLoad' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDIntakeTempFromData converts the given JSON data to a float64.
func OBDIntakeTempFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDIntakeTemp0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'intakeTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'intakeTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// OBDRunTimeFromData converts the given JSON data to a float64.
func OBDRunTimeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToOBDRunTime0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'runTime': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'runTime' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineECT0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'coolantTemp': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'coolantTemp' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilLevelFromData converts the given JSON data to a string.
func PowertrainCombustionEngineEngineOilLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineEngineOilLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oil': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oil' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineEngineOilRelativeLevelFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineEngineOilRelativeLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineEngineOilRelativeLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'oil': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'oil' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineMAFFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineMAFFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineMAF0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'maf': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'maf' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'rpm': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'rpm' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineSpeed1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'engineSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'engineSpeed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainCombustionEngineTPSFromData converts the given JSON data to a float64.
func PowertrainCombustionEngineTPSFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainCombustionEngineTPS0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'throttlePosition': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'throttlePosition' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainFuelSystemRelativeLevelFromData converts the given JSON data to a float64.
func PowertrainFuelSystemRelativeLevelFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainFuelSystemRelativeLevel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelLevel': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelLevel' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainFuelSystemRelativeLevel1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelPercentRemaining': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelPercentRemaining' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainFuelSystemSupportedFuelTypesFromData converts the given JSON data to a string.
func PowertrainFuelSystemSupportedFuelTypesFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToPowertrainFuelSystemSupportedFuelTypes0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelType': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainRangeFromData converts the given JSON data to a float64.
func PowertrainRangeFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainRange0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'range': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'range' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingChargeLimitFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingChargeLimitFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryChargingChargeLimit0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'chargeLimit': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'chargeLimit' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryChargingIsChargingFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryChargingIsChargingFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(bool)
	if ok {
		ret, err = ToPowertrainTractionBatteryChargingIsCharging0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'charging': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'charging' is not of type 'bool' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryCurrentPowerFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryCurrentPowerFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryCurrentPower0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'charger.power': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'charger.power' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryGrossCapacityFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryGrossCapacityFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryGrossCapacity0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'batteryCapacity': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'batteryCapacity' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTractionBatteryStateOfChargeCurrentFromData converts the given JSON data to a float64.
func PowertrainTractionBatteryStateOfChargeCurrentFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTractionBatteryStateOfChargeCurrent0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'soc': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'soc' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromData converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToPowertrainTransmissionTravelledDistance0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'odometer': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'odometer' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// PowertrainTypeFromData converts the given JSON data to a string.
func PowertrainTypeFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToPowertrainType0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'fuelType': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'fuelType' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// SpeedFromData converts the given JSON data to a float64.
func SpeedFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToSpeed0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'vehicleSpeed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'vehicleSpeed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}
	val1, ok := result.Value().(float64)
	if ok {
		ret, err = ToSpeed1(originalDoc, val1)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'speed': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'speed' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// VehicleIdentificationBrandFromData converts the given JSON data to a string.
func VehicleIdentificationBrandFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToVehicleIdentificationBrand0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'make': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'make' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// VehicleIdentificationModelFromData converts the given JSON data to a string.
func VehicleIdentificationModelFromV2Data(originalDoc []byte, result gjson.Result) (ret string, err error) {
	var errs error
	val0, ok := result.Value().(string)
	if ok {
		ret, err = ToVehicleIdentificationModel0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'model': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'model' is not of type 'string' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}

// VehicleIdentificationYearFromData converts the given JSON data to a float64.
func VehicleIdentificationYearFromV2Data(originalDoc []byte, result gjson.Result) (ret float64, err error) {
	var errs error
	val0, ok := result.Value().(float64)
	if ok {
		ret, err = ToVehicleIdentificationYear0(originalDoc, val0)
		if err == nil {
			return ret, nil
		}
		errs = errors.Join(errs, fmt.Errorf("failed to convert 'year': %w", err))
	} else {
		errs = errors.Join(errs, fmt.Errorf("%w, field 'year' is not of type 'float64' got '%v' of type '%T'", errInvalidType, result.Value(), result.Value()))
	}

	return ret, errs
}
