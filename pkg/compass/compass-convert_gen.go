// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package compass

import (
	"errors"
	"fmt"
	"strings"

	"github.com/DIMO-Network/model-garage/pkg/convert"
	"github.com/DIMO-Network/model-garage/pkg/vss"
	"github.com/tidwall/gjson"
)

var errNotFound = errors.New("field not found")

// SignalsFromCompass creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromCompass(baseSignal vss.Signal, jsonData []byte) ([]vss.Signal, []error) {
	var retSignals []vss.Signal

	var val any
	var err error
	var errs []error

	val, err = ChassisAxleRow1WheelLeftTirePressureFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow1WheelLeftTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow1WheelRightTirePressureFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow1WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow1WheelRightTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelLeftTirePressureFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelLeftTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow2WheelLeftTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = ChassisAxleRow2WheelRightTirePressureFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'ChassisAxleRow2WheelRightTirePressure': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "chassisAxleRow2WheelRightTirePressure",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationAltitudeFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationAltitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationAltitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationHeadingFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationHeading': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationHeading",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLatitudeFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLatitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationLatitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = CurrentLocationLongitudeFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'CurrentLocationLongitude': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "currentLocationLongitude",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = IsIgnitionOnFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'IsIgnitionOn': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "isIgnitionOn",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = LowVoltageBatteryCurrentVoltageFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'LowVoltageBatteryCurrentVoltage': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "lowVoltageBatteryCurrentVoltage",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineECTFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineECT': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineECT",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEOPFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEOP': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineEOP",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineEOTFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineEOT': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineEOT",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainCombustionEngineSpeedFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainCombustionEngineSpeed': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainCombustionEngineSpeed",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemAbsoluteLevelFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemAbsoluteLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainFuelSystemAbsoluteLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainFuelSystemRelativeLevelFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainFuelSystemRelativeLevel': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainFuelSystemRelativeLevel",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = PowertrainTransmissionTravelledDistanceFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'PowertrainTransmissionTravelledDistance': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "powertrainTransmissionTravelledDistance",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}

	val, err = SpeedFromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get 'Speed': %w", err))
		}
	} else {
		sig := vss.Signal{
			Name:      "speed",
			TokenID:   baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source:    baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
	return retSignals, errs
}

// ChassisAxleRow1WheelLeftTirePressureFromCompass converts the given JSON data to a float64.
func ChassisAxleRow1WheelLeftTirePressureFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.tirePressure.front.left.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.tirePressure.front.left.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.tirePressure.front.left.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow1WheelRightTirePressureFromCompass converts the given JSON data to a float64.
func ChassisAxleRow1WheelRightTirePressureFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.tirePressure.front.right.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow1WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.tirePressure.front.right.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.tirePressure.front.right.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow1WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelLeftTirePressureFromCompass converts the given JSON data to a float64.
func ChassisAxleRow2WheelLeftTirePressureFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.tirePressure.rear.left.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelLeftTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.tirePressure.rear.left.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.tirePressure.rear.left.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelLeftTirePressure'", errNotFound)
	}

	return ret, errs
}

// ChassisAxleRow2WheelRightTirePressureFromCompass converts the given JSON data to a float64.
func ChassisAxleRow2WheelRightTirePressureFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.tirePressure.rear.right.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToChassisAxleRow2WheelRightTirePressure0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.tirePressure.rear.right.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.tirePressure.rear.right.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'ChassisAxleRow2WheelRightTirePressure'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationAltitudeFromCompass converts the given JSON data to a float64.
func CurrentLocationAltitudeFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.geolocation.altitude.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCurrentLocationAltitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.geolocation.altitude.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.geolocation.altitude.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationAltitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationHeadingFromCompass converts the given JSON data to a float64.
func CurrentLocationHeadingFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.heading"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCurrentLocationHeading0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.heading': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.heading' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationHeading'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLatitudeFromCompass converts the given JSON data to a float64.
func CurrentLocationLatitudeFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.geolocation.latitude"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCurrentLocationLatitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.geolocation.latitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.geolocation.latitude' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLatitude'", errNotFound)
	}

	return ret, errs
}

// CurrentLocationLongitudeFromCompass converts the given JSON data to a float64.
func CurrentLocationLongitudeFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.geolocation.longitude"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToCurrentLocationLongitude0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.geolocation.longitude': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.geolocation.longitude' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'CurrentLocationLongitude'", errNotFound)
	}

	return ret, errs
}

// IsIgnitionOnFromCompass converts the given JSON data to a float64.
func IsIgnitionOnFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.ignition"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToIsIgnitionOn0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.ignition': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.ignition' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'IsIgnitionOn'", errNotFound)
	}

	return ret, errs
}

// LowVoltageBatteryCurrentVoltageFromCompass converts the given JSON data to a float64.
func LowVoltageBatteryCurrentVoltageFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.battery.voltage.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToLowVoltageBatteryCurrentVoltage0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.battery.voltage.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.battery.voltage.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'LowVoltageBatteryCurrentVoltage'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineECTFromCompass converts the given JSON data to a float64.
func PowertrainCombustionEngineECTFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.coolant.temperature.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineECT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.coolant.temperature.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.coolant.temperature.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineECT'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEOPFromCompass converts the given JSON data to a float64.
func PowertrainCombustionEngineEOPFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.oil.pressure.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEOP0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.oil.pressure.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.oil.pressure.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEOP'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineEOTFromCompass converts the given JSON data to a float64.
func PowertrainCombustionEngineEOTFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.oil.temperature.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineEOT0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.oil.temperature.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.oil.temperature.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineEOT'", errNotFound)
	}

	return ret, errs
}

// PowertrainCombustionEngineSpeedFromCompass converts the given JSON data to a float64.
func PowertrainCombustionEngineSpeedFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.engine.speed.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainCombustionEngineSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.engine.speed.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.engine.speed.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainCombustionEngineSpeed'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemAbsoluteLevelFromCompass converts the given JSON data to a float64.
func PowertrainFuelSystemAbsoluteLevelFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.fuel.level.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemAbsoluteLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.fuel.level.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.fuel.level.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemAbsoluteLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainFuelSystemRelativeLevelFromCompass converts the given JSON data to a float64.
func PowertrainFuelSystemRelativeLevelFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.fuel.level.percentage"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainFuelSystemRelativeLevel0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.fuel.level.percentage': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.fuel.level.percentage' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainFuelSystemRelativeLevel'", errNotFound)
	}

	return ret, errs
}

// PowertrainTransmissionTravelledDistanceFromCompass converts the given JSON data to a float64.
func PowertrainTransmissionTravelledDistanceFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.odometer.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToPowertrainTransmissionTravelledDistance0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.odometer.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.odometer.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'PowertrainTransmissionTravelledDistance'", errNotFound)
	}

	return ret, errs
}

// SpeedFromCompass converts the given JSON data to a float64.
func SpeedFromCompass(jsonData []byte) (ret float64, err error) {
	var errs error
	var result gjson.Result
	orName := "labels.speed.value"
	if strings.HasPrefix(orName, "labels") {
		labels := gjson.GetBytes(jsonData, "data.labels")
		result = labels.Get(gjson.Escape(orName[len("labels."):]))
	} else {
		result = gjson.GetBytes(jsonData, "data."+orName)
	}
	if result.Exists() && result.Value() != nil {
		val, ok := result.Value().(string)
		if ok {
			retVal, err := ToSpeed0(jsonData, val)
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.labels.speed.value': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.labels.speed.value' is not of type 'string' got '%v' of type '%T'", convert.InvalidTypeError(), result.Value(), result.Value()))
		}
	}

	if errs == nil {
		return ret, fmt.Errorf("%w 'Speed'", errNotFound)
	}

	return ret, errs
}
