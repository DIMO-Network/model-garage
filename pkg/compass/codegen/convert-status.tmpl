// Code generated by github.com/DIMO-Network/model-garage DO NOT EDIT.
package compass

var errNotFound = errors.New("field not found")

// SignalsFromCompass creates a slice of vss.Signal from the given v1 status JSON data.
// On error, partial results may be returned.
func SignalsFromCompass(baseSignal vss.Signal, jsonData []byte) ([]vss.Signal, []error) {
	var retSignals []vss.Signal
{{ $first := true -}}
{{- $root := . }}
{{- range $idx, $sig := .Signals }}
	{{ if eq (len $sig.Conversions) 0 }} {{ continue }} {{ end -}}
	{{ if $first -}}
	var val any
	var err error
	var errs []error
	{{ $first = false }} {{ end }}

	val, err = {{ $sig.GOName }}FromCompass(jsonData)
	if err != nil {
		if !errors.Is(err, errNotFound) {
			errs = append(errs, fmt.Errorf("failed to get '{{ $sig.GOName }}': %w", err))
		}
	}else {
		sig := vss.Signal{
			Name: "{{ $sig.JSONName }}",
			TokenID: baseSignal.TokenID,
			Timestamp: baseSignal.Timestamp,
			Source: baseSignal.Source,
		}
		sig.SetValue(val)
		retSignals = append(retSignals, sig)
	}
{{- end }}
	return retSignals, errs
}


{{- range $i, $sig := .Signals }}
// {{ $sig.GOName }}FromCompass converts the given JSON data to a {{ $sig.GOType }}.
func {{ $sig.GOName }}FromCompass(jsonData []byte) (ret {{ $sig.GOType }}, err error) {
    var errs error
    var result gjson.Result

	{{- range $j, $conv := .Conversions }}
    orName := "{{ $conv.OriginalName }}"
    if strings.HasPrefix(orName, "labels") {
   		labels := gjson.GetBytes(jsonData, "data.labels")
   		result = labels.Get(gjson.Escape(orName[len("labels."):]))
   	} else {
   		result = gjson.GetBytes(jsonData, "data."+ orName)
   	}
    if result.Exists() && result.Value() != nil {
		{{ if $conv.IsArray -}}
		if result.IsArray() {
			slice{{ $sig.GOName}} := make([]{{ $conv.OriginalType }}, len(result.Array()))
			for i, res := range result.Array() {
				v, ok := res.Value().({{ $conv.OriginalType }})
				if ok{
					slice{{ $sig.GOName}}[i] = v
				} else {
					errs = errors.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' array element %d is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'",  convert.InvalidTypeError(), i, res.Value(), res.Value()))
				}
			}
			retVal, err := To{{ $sig.GOName }}{{ $j }}(jsonData, slice{{ $sig.GOName}})
			if err == nil {
				return retVal, nil
			}
			errs = errors.Join(errs, fmt.Errorf("failed to convert ': %w", err))
		} else {
			errs = errors.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' is not an array", convert.InvalidTypeError()))
		}
		{{ else -}}
        val, ok := result.Value().({{ $conv.OriginalType }})
        if ok {
            retVal, err := To{{ $sig.GOName }}{{ $j }}(jsonData, val)
            if err == nil {
				return retVal, nil
            }
            errs = errors.Join(errs, fmt.Errorf("failed to convert 'data.{{ $conv.OriginalName }}': %w", err))
        } else {
            errs = errors.Join(errs, fmt.Errorf("%w, field 'data.{{ $conv.OriginalName }}' is not of type '{{ $conv.OriginalType }}' got '%v' of type '%T'",  convert.InvalidTypeError(), result.Value(), result.Value()))
        }
		{{- end }}
    }
	{{- end }}

	if errs == nil {
		return ret, fmt.Errorf("%w '{{ $sig.GOName }}'", errNotFound)
	}

    return ret, errs
}
{{- end }}
