// Package convert provides a function to generate conversion functions for a vehicle struct.
package convert

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/DIMO-Network/model-garage/internal/codegen"
)

var (
	// convertFileName is the name of the Go file that will convert JSON data to the vehicle struct.
	convertFileName = "%s-convert.go"
	// convertFuncFileName is the name of the Go file that will contain the conversion functions.
	convertFuncFileName = "%s-convert-funcs.go"
	// convertTestFuncFileName is the name of the Go file that will contain the conversion test functions.
	convertTestFuncFileName = "%s-convert-funcs_test.go"
)

type ConversionData struct {
	Signal  *codegen.SignalInfo
	convIdx int
}

//go:embed convert.tmpl
var convertTemplateStr string

//go:embed convertFunc.tmpl
var convertFuncTemplateStr string

//go:embed convertTestFunc.tmpl
var convertTestsFuncTemplateStr string

const header = `package %s

// This file is automatically populated with conversion functions for each field of the model struct.
// any conversion functions already defined in this package will not be generated.
// Code generated by model-garage.
`

type funcTmplData struct {
	Signal      *codegen.SignalInfo
	ConvIdx     int
	PackageName string
	Conversion  *codegen.ConversionInfo
}

type Config struct {
	// WithTest determines if test functions should be generated.
	WithTest bool
}

// Generate creates a conversion functions for each field of a model struct.
// as well as the entire model struct.
func Generate(tmplData *codegen.TemplateData, outputDir string, cfg Config) (err error) {
	setFileNamesFrom(tmplData.ModelName)

	err = createStructConversion(tmplData, outputDir)
	if err != nil {
		return err
	}

	existingFuncs, err := getDeclaredFunctions(outputDir)
	if err != nil {
		return fmt.Errorf("error getting declared functions: %w", err)
	}

	needsConvertFunc, needsConvertTestFunc := getConversionFunctions(tmplData.Signals, existingFuncs)

	err = createConvertFuncs(tmplData, outputDir, needsConvertFunc)
	if err != nil {
		return err
	}

	if cfg.WithTest {
		err = createConvertTestFunc(tmplData, outputDir, needsConvertTestFunc)
		if err != nil {
			return err
		}
	}

	return nil
}

func setFileNamesFrom(modelName string) {
	lowerModelName := strings.ToLower(modelName)
	convertFileName = fmt.Sprintf(convertFileName, lowerModelName)
	convertFuncFileName = fmt.Sprintf(convertFuncFileName, lowerModelName)
	convertTestFuncFileName = fmt.Sprintf(convertTestFuncFileName, lowerModelName)
}

func createConvertFuncs(tmplData *codegen.TemplateData, outputDir string, needsConvertFunc []ConversionData) error {
	convertFuncTemplate, err := createConvertFuncTemplate()
	if err != nil {
		return err
	}
	if len(needsConvertFunc) == 0 {
		return nil
	}
	filePath := filepath.Join(outputDir, convertFuncFileName)
	err = writeConvertFuncs(needsConvertFunc, convertFuncTemplate, filePath, tmplData.PackageName)
	if err != nil {
		return err
	}
	return nil
}

// getConversionFunctions returns the signals that need conversion functions and test functions.
func getConversionFunctions(signals []*codegen.SignalInfo, existingFuncs map[string]bool) ([]ConversionData, []ConversionData) {
	var needsConvertFunc []ConversionData
	var needsConvertTestFunc []ConversionData
	for _, signal := range signals {
		if len(signal.Conversions) == 0 {
			continue
		}
		for i, _ := range signal.Conversions {
			funcName := convertName(signal) + strconv.Itoa(i)
			if !existingFuncs[funcName] {
				convData := ConversionData{Signal: signal, convIdx: i}
				needsConvertFunc = append(needsConvertFunc, convData)
			}
			funcName = convertTestName(signal) + strconv.Itoa(i)
			if !existingFuncs[funcName] {
				convData := ConversionData{Signal: signal, convIdx: i}
				needsConvertTestFunc = append(needsConvertTestFunc, convData)
			}
		}
	}
	return needsConvertFunc, needsConvertTestFunc
}

// createConvertTestFunc creates test functions for the conversion functions if they do not exist.
func createConvertTestFunc(tmplData *codegen.TemplateData, outputDir string, needsConvertTestFunc []ConversionData) error {
	convertTestFuncTemplate, err := createConvertTestFuncTemplate(tmplData.PackageName)
	if err != nil {
		return err
	}

	if len(needsConvertTestFunc) == 0 {
		return nil
	}

	filePath := filepath.Join(outputDir, convertTestFuncFileName)
	packageName := tmplData.PackageName + "_test"
	err = writeConvertFuncs(needsConvertTestFunc, convertTestFuncTemplate, filePath, packageName)
	if err != nil {
		return err
	}
	return nil
}

// createStructConversion creates the conversion function for converting JSON data to a model struct.
func createStructConversion(tmplData *codegen.TemplateData, outputDir string) error {
	basConversionTemplate, err := createGoTemplate()
	if err != nil {
		return err
	}
	var outBuf bytes.Buffer
	if err = basConversionTemplate.Execute(&outBuf, &tmplData); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	goOutputPath := filepath.Join(outputDir, convertFileName)
	// format and write the go file.
	err = codegen.FormatAndWriteToFile(outBuf.Bytes(), goOutputPath)
	if err != nil {
		return fmt.Errorf("error formatting and writing to file: %w", err)
	}
	return nil
}

func createGoTemplate() (*template.Template, error) {
	tmpl, err := template.New("convertTemplate").Funcs(template.FuncMap{
		"convertName": convertName,
		"lower":       strings.ToLower,
	}).Parse(convertTemplateStr)
	if err != nil {
		return nil, fmt.Errorf("error parsing go struct template: %w", err)
	}
	return tmpl, nil
}

func createConvertFuncTemplate() (*template.Template, error) {
	tmpl, err := template.New("convertFuncTemplate").Funcs(template.FuncMap{
		"convertName": convertName,
	}).Parse(convertFuncTemplateStr)
	if err != nil {
		return nil, fmt.Errorf("error parsing go struct template: %w", err)
	}
	return tmpl, nil
}

func createConvertTestFuncTemplate(packageNameToTest string) (*template.Template, error) {
	tmpl, err := template.New("convertTestFuncTemplate").Funcs(template.FuncMap{
		"convertName":     func(sig *codegen.SignalInfo) string { return fmt.Sprintf("%s.%s", packageNameToTest, convertName(sig)) },
		"convertTestName": convertTestName,
	}).Parse(convertTestsFuncTemplateStr)
	if err != nil {
		return nil, fmt.Errorf("error parsing go struct template: %w", err)
	}
	return tmpl, nil
}

func getDeclaredFunctions(outputPath string) (map[string]bool, error) {
	fset := token.NewFileSet()
	declaredFunctions := map[string]bool{}

	list, err := os.ReadDir(outputPath)
	if err != nil {
		return nil, fmt.Errorf("error reading directory: %w", err)
	}

	for _, d := range list {
		if d.IsDir() || !strings.HasSuffix(d.Name(), ".go") {
			continue
		}
		filename := filepath.Join(outputPath, d.Name())
		err = addFileDeclerations(fset, filename, declaredFunctions)
		if err != nil {
			return nil, err
		}
	}

	return declaredFunctions, nil
}

func addFileDeclerations(fset *token.FileSet, filePath string, declaredFunctions map[string]bool) error {
	src, err := parser.ParseFile(fset, filePath, nil, parser.SkipObjectResolution)
	if err != nil {
		return fmt.Errorf("error parsing file: %w", err)
	}
	for _, decl := range src.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv != nil {
			continue
		}
		declaredFunctions[fn.Name.Name] = true
	}
	return nil
}

func convertName(signal *codegen.SignalInfo) string {
	return "To" + signal.GOName
}

func convertTestName(signal *codegen.SignalInfo) string {
	return "Test" + convertName(signal)
}

// ensureFuncFile checks if the convertFunc file exists and creates it if it does not.
// It also writes the package header to the file if it is created.
func ensureFuncFile(convertFuncPath string, packageName string) error {
	_, err := os.Stat(convertFuncPath)
	if err == nil {
		return nil
	}
	if !os.IsNotExist(err) {
		return fmt.Errorf("error checking for %s file: %w", convertFuncPath, err)
	}
	// create the convertFunc file
	funcFile, err := os.Create(filepath.Clean(convertFuncPath))
	if err != nil {
		return fmt.Errorf("error creating convertFunc file: %w", err)
	}
	_, err = funcFile.WriteString(fmt.Sprintf(header, packageName))
	if err != nil {
		_ = funcFile.Close()
		return fmt.Errorf("error writing to convertFunc file: %w", err)
	}
	err = funcFile.Close()
	if err != nil {
		return fmt.Errorf("error closing convertFunc file: %w", err)
	}

	return nil
}

func writeConvertFuncs(needsConvertFunc []ConversionData, tmpl *template.Template, outputPath string, packageName string) error {
	// check if we need to create convertFunc file
	err := ensureFuncFile(outputPath, packageName)
	if err != nil {
		return err
	}

	convertData, err := os.ReadFile(filepath.Clean(outputPath))
	if err != nil {
		return fmt.Errorf("error reading convertFunc file: %w", err)
	}
	convertBuff := bytes.NewBuffer(convertData)
	for _, convData := range needsConvertFunc {
		data := funcTmplData{
			PackageName: packageName,
			Signal:      convData.Signal,
			ConvIdx:     convData.convIdx,
			Conversion:  convData.Signal.Conversions[convData.convIdx],
		}
		if err = tmpl.Execute(convertBuff, &data); err != nil {
			return fmt.Errorf("error executing convertFunc template: %w", err)
		}
	}
	err = codegen.FormatAndWriteToFile(convertBuff.Bytes(), outputPath)
	if err != nil {
		return fmt.Errorf("error formatting and writing to file: %w", err)
	}
	return nil
}
